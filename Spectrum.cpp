#include "Spectrum.hpp"

#include <chrono>
#include <cmath>
#include <iostream>
#include <random>
#include <ratio>
#include <tuple>

#include "Shader.hpp"

void Spectrum::init(int size, int patchSize)
{
	this->size = size;
	this->log2size = static_cast<int>(log2(size));
	this->patchSize = patchSize;

	start = std::chrono::system_clock::now();

	// Calculate the reverse indices and initial random data
	calculateReverseIndices();
	generateGaussianDist();

	// Load all the shaders
	phillipsShader = linkProgram({loadShader(GL_COMPUTE_SHADER, "shaders/compiled/compute/phillips_spec.spv")});
	conjugateShader = linkProgram({loadShader(GL_COMPUTE_SHADER, "shaders/compiled/compute/conjugate.spv")});
	butterflyShader = linkProgram({loadShader(GL_COMPUTE_SHADER, "shaders/compiled/compute/butterfly.spv")});
	timeSpectrumShader = linkProgram({loadShader(GL_COMPUTE_SHADER, "shaders/compiled/compute/time_spec.spv")});
	fftShader = linkProgram({loadShader(GL_COMPUTE_SHADER, "shaders/compiled/compute/fft.spv")});
	combineShader = linkProgram({loadShader(GL_COMPUTE_SHADER, "shaders/compiled/compute/combine_tex.spv")});

	// Generate all the necessary textures and buffers
	textures = new GLuint[numTextures];
	glGenTextures(numTextures, textures);

	for (int i = 0; i < numTextures - 1; i++)
	{
		glBindTexture(GL_TEXTURE_2D, textures[i]);
		glTexStorage2D(GL_TEXTURE_2D, 1, GL_RGBA16F, size, size);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	}

	glBindTexture(GL_TEXTURE_2D, textures[InitialSpectrum]);
	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA16F, size, size, 0, GL_RGBA, GL_FLOAT, initialRandomData.data());
	// This is necessary because the default filter is GL_LINEAR_MIPMAP_LINEAR and would result in a "mipmap incomplete"
	// texture and the compute shader wont accept it.
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

	glGenTextures(1, &butterflyTexture);
	glBindTexture(GL_TEXTURE_2D, butterflyTexture);
	glTexStorage2D(GL_TEXTURE_2D, 1, GL_RGBA16F, static_cast<GLsizei>(log2(size)), size);

	glGenBuffers(1, &reverseIndexBuffer);
	glBindBuffer(GL_SHADER_STORAGE_BUFFER, reverseIndexBuffer);
	glBufferData(GL_SHADER_STORAGE_BUFFER, reverseIndices.size() * sizeof(int), reverseIndices.data(), GL_STREAM_DRAW);

	// Execute compute shaders
	// butterfly shader
	glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 1, reverseIndexBuffer);
	glBindImageTexture(0, butterflyTexture, 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA16F);
	glUseProgram(butterflyShader);
	glDispatchCompute(log2size, size / 16, 1);

	// spectrum shader
	glBindImageTexture(0, textures[InitialSpectrum], 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA16F);
	glUseProgram(phillipsShader);
	glUniform1i(0, patchSize);
	glDispatchCompute(size / 8, size / 8, 1);

	// To make sure spectrum is generated by the time we execute conjugate shader
	glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT);

	// conjugate shader
	glUseProgram(conjugateShader);
	glDispatchCompute(size / 8, size / 8, 1);

	glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT);
}

void Spectrum::combineTextures(float scale)
{
	glUseProgram(combineShader);
	glBindImageTexture(0, textures[DyDx], 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA16F);
	glBindImageTexture(1, textures[DzDzx], 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA16F);
	glBindImageTexture(2, textures[DyxDyz], 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA16F);
	glBindImageTexture(3, textures[DxxDzz], 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA16F);
	glBindImageTexture(4, textures[Displacements], 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA16F);
	glBindImageTexture(5, textures[Derivates], 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA16F);
	glUniform1f(0, scale);
	glDispatchCompute(size / 16, size / 16, 1);
}

void Spectrum::updateSpectrumTexture()
{
	auto time = std::chrono::system_clock::now();
	auto timeSinceStart = std::chrono::duration_cast<std::chrono::duration<float, std::ratio<1>>>(time - start).count();

	glUseProgram(timeSpectrumShader);
	glBindImageTexture(0, textures[InitialSpectrum], 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA16F);
	glBindImageTexture(1, textures[DyDx], 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA16F);
	glBindImageTexture(2, textures[DzDzx], 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA16F);
	glBindImageTexture(3, textures[DyxDyz], 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA16F);
	glBindImageTexture(4, textures[DxxDzz], 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA16F);
	glUniform1f(0, timeSinceStart);
	glUniform1i(1, patchSize);
	glDispatchCompute(size / 8, size / 8, 1);
	glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT);
}

void Spectrum::fft()
{
	dispatchFFT(textures[DyDx]);
	dispatchFFT(textures[DzDzx]);
	dispatchFFT(textures[DyxDyz]);
	dispatchFFT(textures[DxxDzz]);
}

void Spectrum::dispatchFFT(GLuint spectrum)
{
	glUseProgram(fftShader);

	glBindImageTexture(0, butterflyTexture, 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA16F);
	glBindImageTexture(1, spectrum, 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA16F);
	glBindImageTexture(2, textures[Buffer], 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA16F);

	int buffer = 0;

	// horizontal
	glUniform1i(0, 0);
	for (int i = 0; i < log2size; i++)
	{
		// Set stage
		glUniform1i(1, buffer);
		glUniform1i(2, i);
		glDispatchCompute(size / 16, size / 16, 1);
		glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT);
		buffer = !buffer;
	}

	// vertical
	glUniform1i(0, 1);
	for (int i = 0; i < log2size; i++)
	{
		glUniform1i(1, buffer);
		glUniform1i(2, i);
		glDispatchCompute(size / 16, size / 16, 1);
		glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT);
		buffer = !buffer;
	}

	// Execute inversion and permutation shader
	glUniform1i(0, 2);
	glDispatchCompute(size / 16, size / 16, 1);
	glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT);
}

void Spectrum::cleanup()
{
	glDeleteProgram(phillipsShader);
	glDeleteProgram(conjugateShader);
	glDeleteProgram(butterflyShader);
	glDeleteProgram(timeSpectrumShader);
	glDeleteProgram(fftShader);
	glDeleteProgram(combineShader);

	glDeleteTextures(numTextures, textures);
	delete textures;
	glDeleteTextures(1, &butterflyTexture);

	glDeleteBuffers(1, &reverseIndexBuffer);
}

void Spectrum::calculateReverseIndices()
{
	int numBits = log2(size);
	for (int i = 0; i < size; i++)
	{
		int reversed = 0;
		for (int j = 0; j < numBits; j++)
		{
			if (i & static_cast<int>(pow(2, j)))
			{
				reversed |= static_cast<int>(pow(2, numBits - j - 1));
			}
		}
		reverseIndices.push_back(reversed);
	}
}

void Spectrum::generateGaussianDist()
{
	std::random_device device;
	std::normal_distribution<GLfloat> dist{0, 1};
	std::mt19937 gen(device());

	auto randVal = [&dist, &gen]() -> GLfloat { return dist(gen); };

	for (int i = 0; i < size * size; i++)
	{
		Color col{randVal(), randVal(), 0, 0};
		initialRandomData.push_back(col);
	}
}
