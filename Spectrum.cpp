#include "Spectrum.hpp"

#include <chrono>
#include <cmath>
#include <fstream>
#include <glm/geometric.hpp>
#include <initializer_list>
#include <iostream>
#include <random>
#include <ratio>

#include <glm/glm.hpp>

#include "Shader.hpp"

std::vector<int> Spectrum::reverseIndices = std::vector<int>();
bool Spectrum::initDataGenerated = false;

void Spectrum::init(int size,
                    int patchSize,
                    float scale,
                    float depth,
                    float fetch,
                    float windSpeed,
                    float cutoffLow,
                    float cutoffHigh,
                    float spread_blend,
                    float swell,
                    float angle)
{
	this->size = size;
	this->log2size = static_cast<int>(log2(size));
	this->patchSize = patchSize;
	this->scale = scale;
	this->depth = depth;
	this->fetch = fetch;
	this->windSpeed = windSpeed;
	this->cutoffLow = cutoffLow;
	this->cutoffHigh = cutoffHigh;
	this->spread_blend = spread_blend;
	this->swell = swell;
	this->angle = angle;

	start = std::chrono::system_clock::now();

	// Generate all the necessary textures and buffers
	textures = new GLuint[numTextures];

	glGenTextures(numTextures, textures);
	glGenTextures(1, &butterflyTexture);
	glGenBuffers(1, &reverseIndexBuffer);

	formatTextures();

	// Calculate the reverse indices and initial random data
	if (!initDataGenerated)
	{
		calculateReverseIndices();
		generateGaussianDist();
		initDataGenerated = true;
	}

	// Load all the shaders
	loadShaders();

	genInitDataAndUpload();
}

void Spectrum::regen(int size,
                     int patchSize,
                     float scale,
                     float depth,
                     float fetch,
                     float windSpeed,
                     float cutoffLow,
                     float cutoffHigh,
                     float spread_blend,
                     float swell,
                     float angle)
{
	this->size = size;
	this->patchSize = patchSize;
	this->log2size = static_cast<int>(log2(size));
	this->scale = scale;
	this->depth = depth;
	this->windSpeed = windSpeed;
	this->fetch = fetch;
	this->cutoffLow = cutoffLow;
	this->cutoffHigh = cutoffHigh;
	this->spread_blend = spread_blend;
	this->swell = swell;
	this->angle = angle;

	reverseIndices.clear();
	calculateReverseIndices();
	formatTextures();
	generateGaussianDist();
	genInitDataAndUpload();
}

void Spectrum::loadShaders()
{
	if (jonswapShader)
	{
		glDeleteProgram(jonswapShader);
		glDeleteProgram(phillipsShader);
		glDeleteProgram(conjugateShader);
		glDeleteProgram(butterflyShader);
		glDeleteProgram(timeSpectrumShader);
		glDeleteProgram(fftShader);
		glDeleteProgram(combineShader);
	}

	jonswapShader = linkProgram({loadShader(GL_COMPUTE_SHADER, "./shaders/compiled/compute/jonswap_spec.spv")});
	phillipsShader = linkProgram({loadShader(GL_COMPUTE_SHADER, "./shaders/compiled/compute/phillips_spec.spv")});
	conjugateShader = linkProgram({loadShader(GL_COMPUTE_SHADER, "./shaders/compiled/compute/conjugate.spv")});
	butterflyShader = linkProgram({loadShader(GL_COMPUTE_SHADER, "./shaders/compiled/compute/butterfly.spv")});
	timeSpectrumShader = linkProgram({loadShader(GL_COMPUTE_SHADER, "./shaders/compiled/compute/time_spec.spv")});
	fftShader = linkProgram({loadShader(GL_COMPUTE_SHADER, "./shaders/compiled/compute/fft.spv")});
	combineShader = linkProgram({loadShader(GL_COMPUTE_SHADER, "./shaders/compiled/compute/combine_tex.spv")});
}

void Spectrum::genInitDataAndUpload()
{
	glBindBuffer(GL_SHADER_STORAGE_BUFFER, reverseIndexBuffer);
	glBufferData(GL_SHADER_STORAGE_BUFFER, reverseIndices.size() * sizeof(int), reverseIndices.data(), GL_STREAM_DRAW);

	// Execute compute shaders
	// butterfly shader
	glUseProgram(butterflyShader);
	glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 1, reverseIndexBuffer);
	glBindImageTexture(0, butterflyTexture, 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);
	glDispatchCompute(log2size, size / 16 / 2, 1);

	// spectrum shader
	glUseProgram(jonswapShader);
	glBindImageTexture(0, textures[WorkingSpectrum], 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);
	glBindImageTexture(1, textures[RandomData], 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);
	glUniform1i(0, patchSize);
	glUniform1f(1, windSpeed);
	glUniform1f(2, fetch);
	glUniform1f(3, depth);
	glUniform1f(4, cutoffLow);
	glUniform1f(5, cutoffHigh);
	glUniform1f(6, spread_blend);
	glUniform1f(7, swell);
	glUniform1f(8, angle);
	glDispatchCompute(size / 8, size / 8, 1);

	// To make sure spectrum is generated by the time we execute conjugate shader
	glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT);

	glUseProgram(conjugateShader);
	glBindImageTexture(0, textures[WorkingSpectrum], 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);
	glDispatchCompute(size / 8, size / 8, 1);
	glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT);
}

void Spectrum::formatTextures()
{
	for (int i = 0; i < numTextures; i++)
	{
		glBindTexture(GL_TEXTURE_2D, textures[i]);
		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA32F, size, size, 0, GL_RGBA, GL_FLOAT, nullptr);
		// This is necessary because the default filter is GL_LINEAR_MIPMAP_LINEAR and would result in a "mipmap incomplete"
		// texture and the compute shader wont accept it.
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
	}

	glBindTexture(GL_TEXTURE_2D, textures[Displacements]);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

	glBindTexture(GL_TEXTURE_2D, butterflyTexture);
	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA32F, static_cast<GLsizei>(log2(size)), size, 0, GL_RGBA, GL_FLOAT, nullptr);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

	glBindTexture(GL_TEXTURE_2D, textures[Derivates]);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

	glObjectLabel(GL_TEXTURE, textures[Derivates], -1, "Derivatives");
	glObjectLabel(GL_TEXTURE, textures[Displacements], -1, "Displacements");
	glObjectLabel(GL_TEXTURE, textures[WorkingSpectrum], -1, "Working Spectrum");
	glObjectLabel(GL_TEXTURE, textures[RandomData], -1, "Random Data");
	glObjectLabel(GL_TEXTURE, textures[DyDx], -1, "DyDxTex");
}

void Spectrum::combineTextures(float scale)
{
	glUseProgram(combineShader);
	glBindImageTexture(0, textures[DyDx], 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);
	glBindImageTexture(1, textures[DzDzx], 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);
	glBindImageTexture(2, textures[DyxDyz], 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);
	glBindImageTexture(3, textures[DxxDzz], 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);
	glBindImageTexture(4, textures[Displacements], 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);
	glBindImageTexture(5, textures[Derivates], 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);
	glUniform1f(0, scale);
	glDispatchCompute(size / 16, size / 16, 1);
	glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT);

	glGenerateTextureMipmap(textures[Derivates]);
	glGenerateTextureMipmap(textures[Displacements]);
}

void Spectrum::updateSpectrumTexture()
{
	auto time = std::chrono::system_clock::now();
	auto timeSinceStart = std::chrono::duration_cast<std::chrono::duration<float, std::ratio<1>>>(time - start).count();

	glUseProgram(timeSpectrumShader);
	glBindImageTexture(0, textures[WorkingSpectrum], 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);
	glBindImageTexture(1, textures[DyDx], 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);
	glBindImageTexture(2, textures[DzDzx], 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);
	glBindImageTexture(3, textures[DyxDyz], 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);
	glBindImageTexture(4, textures[DxxDzz], 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);
	glUniform1f(0, timeSinceStart);
	glUniform1i(1, patchSize);
	glDispatchCompute(size / 8, size / 8, 1);
	glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT);
}

void Spectrum::fft()
{
	dispatchFFT(textures[DyDx]);
	dispatchFFT(textures[DzDzx]);
	dispatchFFT(textures[DyxDyz]);
	dispatchFFT(textures[DxxDzz]);
}

void Spectrum::dispatchFFT(GLuint spectrum)
{
	glUseProgram(fftShader);
	glBindImageTexture(0, butterflyTexture, 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);
	glBindImageTexture(1, spectrum, 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);
	glBindImageTexture(2, textures[Buffer], 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);

	int buffer = 0;

	// horizontal
	glUniform1i(0, 0);
	for (int i = 0; i < log2size; i++)
	{
		// Set stage
		glUniform1i(1, buffer);
		glUniform1i(2, i);
		glDispatchCompute(size / 16, size / 16, 1);
		glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT);
		buffer = !buffer;
	}

	// vertical
	glUniform1i(0, 1);
	for (int i = 0; i < log2size; i++)
	{
		glUniform1i(1, buffer);
		glUniform1i(2, i);
		glDispatchCompute(size / 16, size / 16, 1);
		glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT);
		buffer = !buffer;
	}

	// Execute inversion and permutation shader
	glUniform1i(0, 2);
	glDispatchCompute(size / 16, size / 16, 1);
	glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT);
}

void Spectrum::cleanup()
{
	glDeleteProgram(phillipsShader);
	glDeleteProgram(jonswapShader);
	glDeleteProgram(conjugateShader);
	glDeleteProgram(butterflyShader);
	glDeleteProgram(timeSpectrumShader);
	glDeleteProgram(fftShader);
	glDeleteProgram(combineShader);

	glDeleteTextures(numTextures, textures);
	glDeleteTextures(1, &butterflyTexture);
	delete textures;

	glDeleteBuffers(1, &reverseIndexBuffer);
}

int Spectrum::reverseBitsR(int num, int depth)
{
	if (depth == 0)
		return 0;
	int res = 0;
	res |= reverseBitsR(num / 2, depth - 1);
	res |= ((num % 2) << (depth - 1));
	return res;
}

void Spectrum::calculateReverseIndices()
{
	reverseIndices.resize(size, 0);
	for (int i = 0; i < size; i++)
	{
		if (reverseIndices[i])
			continue;

		int reversed = reverseBitsR(i, ceil(log2(size)));
		reverseIndices[i] = reversed;
		reverseIndices[reversed] = i;
	}
}

void Spectrum::generateGaussianDist()
{
	std::random_device device;
	std::normal_distribution<GLfloat> dist{0, 1};
	std::mt19937 gen(device());

	auto randVal = [&dist, &gen]() -> GLfloat { return dist(gen); };

	Color *randomData = new Color[size * size];

	for (int i = 0; i < size * size; i++)
	{
		randomData[i].r = randVal();
		randomData[i].g = randVal();
		randomData[i].b = 0;
		randomData[i].a = 0;
	}

	glTextureSubImage2D(textures[RandomData], 0, 0, 0, size, size, GL_RGBA, GL_FLOAT, randomData);
	delete[] randomData;
}
