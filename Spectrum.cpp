#include "Spectrum.hpp"

#include <chrono>
#include <cmath>
#include <iostream>
#include <random>
#include <ratio>
#include <tuple>

#include "Shader.hpp"

void Spectrum::init(int size)
{
	this->size = size;
	this->log2size = static_cast<int>(log2(size));

	start = std::chrono::system_clock::now();

	// Calculate the reverse indices and initial random data
	calculateReverseIndices();
	generateGaussianDist();

	// Load all the shaders
	phillipsShader = linkProgram({loadShader(GL_COMPUTE_SHADER, "shaders/compiled/compute/phillips_spec.spv")});
	conjugateShader = linkProgram({loadShader(GL_COMPUTE_SHADER, "shaders/compiled/compute/conjugate.spv")});
	butterflyShader = linkProgram({loadShader(GL_COMPUTE_SHADER, "shaders/compiled/compute/butterfly.spv")});
	timeSpectrumShader = linkProgram({loadShader(GL_COMPUTE_SHADER, "shaders/compiled/compute/time_spec.spv")});

	// Generate all the necessary textures and buffers
	glGenTextures(1, &initialSpectrumTexture);
	glBindTexture(GL_TEXTURE_2D, initialSpectrumTexture);
	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA16F, size, size, 0, GL_RGBA, GL_FLOAT, initialRandomData.data());
	// This is necessary because the default filter is GL_LINEAR_MIPMAP_LINEAR and would result in a "mipmap incomplete"
	// texture and the compute shader wont accept it.
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);

	glGenTextures(1, &spectrumTexture);
	glBindTexture(GL_TEXTURE_2D, spectrumTexture);
	glTexStorage2D(GL_TEXTURE_2D, 1, GL_RGBA16F, size, size);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);

	glGenTextures(1, &butterflyTexture);
	glBindTexture(GL_TEXTURE_2D, butterflyTexture);
	glTexStorage2D(GL_TEXTURE_2D, 1, GL_RGBA16F, static_cast<GLsizei>(log2(size)), size);

	glGenBuffers(1, &reverseIndexBuffer);
	glBindBuffer(GL_SHADER_STORAGE_BUFFER, reverseIndexBuffer);
	glBufferData(GL_SHADER_STORAGE_BUFFER, reverseIndices.size() * sizeof(int), reverseIndices.data(), GL_STREAM_DRAW);

	// Execute compute shaders
	// butterfly shader
	glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 1, reverseIndexBuffer);
	glBindImageTexture(0, butterflyTexture, 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA16F);
	glUseProgram(butterflyShader);
	glDispatchCompute(log2size, size / 16, 1);

	// spectrum shader
	glBindImageTexture(0, initialSpectrumTexture, 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA16F);
	glUseProgram(phillipsShader);
	glDispatchCompute(size / 8, size / 8, 1);

	// To make sure spectrum is generated by the time we execute conjugate shader
	glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT);

	// conjugate shader
	glUseProgram(conjugateShader);
	glDispatchCompute(size / 8, size / 8, 1);

	glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT);
}

void Spectrum::updateSpectrumTexture()
{
	auto time = std::chrono::system_clock::now();
	auto timeSinceStart = std::chrono::duration_cast<std::chrono::duration<float, std::ratio<1>>>(time - start).count();

	glUseProgram(timeSpectrumShader);
	glBindImageTexture(0, initialSpectrumTexture, 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA16F);
	glBindImageTexture(1, spectrumTexture, 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA16F);
	glUniform1f(0, timeSinceStart);
	glDispatchCompute(size / 8, size / 8, 1);
	glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT);
}

void Spectrum::cleanup()
{
	glDeleteProgram(phillipsShader);
	glDeleteProgram(conjugateShader);
	glDeleteProgram(butterflyShader);
	glDeleteProgram(timeSpectrumShader);

	glDeleteTextures(1, &spectrumTexture);
	glDeleteTextures(1, &butterflyTexture);
	glDeleteTextures(1, &initialSpectrumTexture);
	glDeleteTextures(1, &spectrumTexture);

	glDeleteBuffers(1, &reverseIndexBuffer);
}

void Spectrum::calculateReverseIndices()
{
	int numBits = log2(size);
	for (int i = 0; i < size; i++)
	{
		int reversed = 0;
		for (int j = 0; j < numBits; j++)
		{
			if (i & static_cast<int>(pow(2, j)))
			{
				reversed |= static_cast<int>(pow(2, numBits - j - 1));
			}
		}
		reverseIndices.push_back(reversed);
	}
}

void Spectrum::generateGaussianDist()
{
	std::random_device device;
	std::normal_distribution<GLfloat> dist{0, 1};
	std::mt19937 gen(device());

	auto randVal = [&dist, &gen]() -> GLfloat { return dist(gen); };

	for (int i = 0; i < size * size; i++)
	{
		Color col{randVal(), randVal(), 0, 0};
		initialRandomData.push_back(col);
	}
}
