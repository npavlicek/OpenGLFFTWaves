#version 460 core

#define PI 3.1415926535897932384626433

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0, rgba16f) uniform image2D spectrum;

layout(location = 0) uniform int patchSize;

float jonswap(float omega) {
	float gamma = 3.3;
	float gravity = 9.81;
	float fetch = 800.0;
	float avgWindSpeed = 25.0;

	float omega_p = 22 * (pow(gravity, 2) / (avgWindSpeed * fetch));

	float sigma = (omega > omega_p) ? 0.09 : 0.07;

	float alpha = pow(pow(avgWindSpeed, 2) / (fetch * gravity), 0.22) * 0.076;

	//float r = -pow(omega - omega_p, 2)/(2 * pow(sigma, 2) * pow(omega_p, 2));
	//r = exp(r);
	float r = 4;

	float res = alpha * pow(gravity, 2) / pow(omega, 5);
	res *= exp(-(5.0/4.0)*pow(omega_p/omega, 4));
	res *= pow(gamma, r);

	if (isnan(res)) res = 0.0;

	return res;
}

void main() {
	uvec3 id = gl_GlobalInvocationID;

	ivec2 size = imageSize(spectrum);

	float n = id.x - size.x / 2.0;
	float m = id.y - size.y / 2.0;

	float delta = 2 * PI / patchSize;

	float x = n * delta;
	float y = m * delta;

	vec2 coords = vec2(x, y);

	float k_mag = length(coords);

	float depth = 50.0;
	float omega = sqrt(9.81 * k_mag * tanh(k_mag * depth));

	float dOmegaNum = 9.81 * (tanh(depth * k_mag) + (depth * k_mag * (1 / pow(cosh(depth * k_mag), 2))));

	float dOmega = abs(dOmegaNum / (2.0 * omega));
	float js = sqrt(2 * jonswap(omega) * dOmega * delta * delta / k_mag);

	vec4 val = imageLoad(spectrum, ivec2(id.xy));

	float newR = val.r * js;
	float newG = val.g * js;

	if (isnan(newR)) newR = 0.0;
	if (isnan(newG)) newG = 0.0;

	imageStore(spectrum, ivec2(id.xy), vec4(newR, newG, 0, 1));
}
